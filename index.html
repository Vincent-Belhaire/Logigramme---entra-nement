<script>
// --- Helpers & state ---
const $ = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

const exercises = $$('.exercise');
const scoreEl = $('#score');
const totalEl = $('#total');
const prevBtn = $('#prevBtn');
const nextBtn = $('#nextBtn');
const resetBtn = $('#resetBtn');
const exportBtn = $('#exportBtn');

let current = 0;
const APP_VERSION = '1.2.0';
let results = {};

// Charger les résultats sauvegardés
try {
  results = JSON.parse(localStorage.getItem('logi_results') || '{}');
} catch(e) {
  results = {};
}

// Vérifier la version
const storedVer = localStorage.getItem('logi_version');
if(storedVer !== APP_VERSION) {
  localStorage.removeItem('logi_results');
  results = {};
  localStorage.setItem('logi_version', APP_VERSION);
}

function totalPoints() {
  return exercises.reduce((s, ex) => s + Number(ex.dataset.points || 0), 0);
}

function save() {
  localStorage.setItem('logi_results', JSON.stringify(results));
  localStorage.setItem('logi_version', APP_VERSION);
}

function updateScore() {
  const sum = Object.values(results).reduce((a, b) => a + Number(b || 0), 0);
  scoreEl.textContent = sum;
  totalEl.textContent = totalPoints();
}

function unlockSolutions(ex) {
  $$('details.sol[aria-disabled="true"]', ex).forEach(d => {
    d.setAttribute('aria-disabled', 'false');
    d.style.display = 'block';
  });
}

function show(i) {
  exercises.forEach((ex, idx) => {
    ex.classList.toggle('active', idx === i);
  });
  current = i;
  prevBtn.disabled = i === 0;
  nextBtn.disabled = i === exercises.length - 1;
  
  setTimeout(() => {
    const t = exercises[i].querySelector('.title');
    if (t) t.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 50);
}

// Navigation
prevBtn.addEventListener('click', () => show(Math.max(0, current - 1)));
nextBtn.addEventListener('click', () => show(Math.min(exercises.length - 1, current + 1)));

resetBtn.addEventListener('click', () => {
  if (!confirm('Réinitialiser toutes les réponses ?')) return;
  localStorage.removeItem('logi_results');
  results = {};
  location.reload();
});

exportBtn.addEventListener('click', () => {
  const blob = new Blob([JSON.stringify({ date: new Date().toISOString(), results }, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'resultats-logigrammes.json';
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 1000);
});

// --- Gestion tactile pour tablettes ---
function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}

// --- Fonctions pour le drag & drop tactile ---
function setupTouchDragAndDrop() {
  if (!isTouchDevice()) return;

  let activeTouch = null;
  let dragElement = null;
  let ghostElement = null;
  let startX, startY;

  // Désactiver le drag natif sur les éléments tactiles
  $$('.label[draggable="true"]').forEach(el => {
    el.setAttribute('draggable', 'false');
  });

  // Gestionnaire de début de toucher
  document.addEventListener('touchstart', (e) => {
    if (activeTouch) return;

    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    
    // Vérifier si on touche un label
    const label = target.closest('.label');
    if (label) {
      e.preventDefault();
      activeTouch = touch.identifier;
      dragElement = label;
      startX = touch.clientX;
      startY = touch.clientY;

      // Créer un élément fantôme
      ghostElement = label.cloneNode(true);
      ghostElement.style.position = 'fixed';
      ghostElement.style.zIndex = '10000';
      ghostElement.style.opacity = '0.8';
      ghostElement.style.pointerEvents = 'none';
      ghostElement.style.transform = 'translate(-50%, -50%)';
      ghostElement.style.width = label.offsetWidth + 'px';
      document.body.appendChild(ghostElement);

      // Cacher l'élément original
      label.style.opacity = '0.4';
    }

    // Vérifier si on touche un élément dans une zone (pour le réorganiser)
    const zoneChip = target.closest('.zone-chip');
    if (zoneChip) {
      e.preventDefault();
      activeTouch = touch.identifier;
      dragElement = zoneChip;
      startX = touch.clientX;
      startY = touch.clientY;

      ghostElement = zoneChip.cloneNode(true);
      ghostElement.style.position = 'fixed';
      ghostElement.style.zIndex = '10000';
      ghostElement.style.opacity = '0.8';
      ghostElement.style.pointerEvents = 'none';
      ghostElement.style.transform = 'translate(-50%, -50%)';
      document.body.appendChild(ghostElement);

      zoneChip.style.opacity = '0.4';
    }
  });

  // Gestionnaire de mouvement de toucher
  document.addEventListener('touchmove', (e) => {
    if (!activeTouch || !ghostElement) return;

    const touch = Array.from(e.touches).find(t => t.identifier === activeTouch);
    if (!touch) return;

    e.preventDefault();

    // Déplacer le fantôme
    ghostElement.style.left = touch.clientX + 'px';
    ghostElement.style.top = touch.clientY + 'px';

    // Trouver la zone cible
    const zones = $$('.zone');
    let targetZone = null;

    for (const zone of zones) {
      const rect = zone.getBoundingClientRect();
      if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
          touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
        targetZone = zone;
        break;
      }
    }

    // Mettre en surbrillance la zone cible
    zones.forEach(zone => zone.classList.remove('hover'));
    if (targetZone) {
      targetZone.classList.add('hover');
    }
  });

  // Gestionnaire de fin de toucher
  document.addEventListener('touchend', (e) => {
    if (!activeTouch || !ghostElement) return;

    const touch = e.changedTouches[0];
    if (touch.identifier !== activeTouch) return;

    e.preventDefault();

    // Trouver la zone cible
    const zones = $$('.zone');
    let targetZone = null;

    for (const zone of zones) {
      const rect = zone.getBoundingClientRect();
      if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
          touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
        targetZone = zone;
        break;
      }
    }

    // Traiter le drop
    if (targetZone && dragElement) {
      const key = dragElement.dataset.key;
      const accepted = targetZone.dataset.accept;

      if (accepted === key) {
        // Drop valide
        targetZone.innerHTML = '<span class="zone-chip" data-key="' + key + '">' + dragElement.textContent + '</span>';
        targetZone.dataset.filled = key;
        targetZone.classList.add('filled');

        // Cacher le label original s'il existe
        const originalLabel = $('.label[data-key="' + key + '"]');
        if (originalLabel) {
          originalLabel.style.display = 'none';
        }

        // Si on déplaçait un élément d'une zone, vider l'ancienne zone
        if (dragElement.classList.contains('zone-chip')) {
          const oldZone = dragElement.closest('.zone');
          if (oldZone) {
            oldZone.innerHTML = '';
            oldZone.classList.remove('filled');
            oldZone.removeAttribute('data-filled');
          }
        }
      }
    }

    // Nettoyer
    if (dragElement) {
      dragElement.style.opacity = '1';
    }
    if (ghostElement && ghostElement.parentNode) {
      ghostElement.parentNode.removeChild(ghostElement);
    }

    $$('.zone').forEach(zone => zone.classList.remove('hover'));

    activeTouch = null;
    dragElement = null;
    ghostElement = null;
  });

  // Empêcher le défilement pendant le drag
  document.addEventListener('touchmove', (e) => {
    if (activeTouch) {
      e.preventDefault();
    }
  }, { passive: false });
}

// --- Gestion tactile pour le tri des étapes (EX1) ---
function setupTouchSorting() {
  if (!isTouchDevice()) return;

  const list = $('#orderList');
  if (!list) return;

  let activeTouch = null;
  let draggedItem = null;
  let ghostItem = null;
  let startY;

  list.addEventListener('touchstart', (e) => {
    if (activeTouch) return;

    const touch = e.touches[0];
    const target = touch.target.closest('.chip');
    if (!target) return;

    e.preventDefault();
    activeTouch = touch.identifier;
    draggedItem = target;
    startY = touch.clientY;

    // Créer un fantôme
    ghostItem = target.cloneNode(true);
    ghostItem.style.position = 'fixed';
    ghostItem.style.zIndex = '10000';
    ghostItem.style.opacity = '0.8';
    ghostItem.style.pointerEvents = 'none';
    ghostItem.style.transform = 'translate(-50%, -50%)';
    ghostItem.style.width = target.offsetWidth + 'px';
    document.body.appendChild(ghostItem);

    target.style.opacity = '0.4';
    target.classList.add('dragging');
  });

  list.addEventListener('touchmove', (e) => {
    if (!activeTouch || !ghostItem) return;

    const touch = Array.from(e.touches).find(t => t.identifier === activeTouch);
    if (!touch) return;

    e.preventDefault();

    // Déplacer le fantôme
    ghostItem.style.left = touch.clientX + 'px';
    ghostItem.style.top = touch.clientY + 'px';

    // Trouver la nouvelle position
    const chips = $$('.chip:not(.dragging)', list);
    let insertBefore = null;

    for (const chip of chips) {
      const rect = chip.getBoundingClientRect();
      const middleY = rect.top + rect.height / 2;

      if (touch.clientY < middleY) {
        insertBefore = chip;
        break;
      }
    }

    // Déplacer l'élément
    if (insertBefore) {
      list.insertBefore(draggedItem, insertBefore);
    } else {
      list.appendChild(draggedItem);
    }
  });

  list.addEventListener('touchend', (e) => {
    if (!activeTouch) return;

    const touch = e.changedTouches[0];
    if (touch.identifier !== activeTouch) return;

    e.preventDefault();

    // Nettoyer
    if (draggedItem) {
      draggedItem.style.opacity = '1';
      draggedItem.classList.remove('dragging');
    }
    if (ghostItem && ghostItem.parentNode) {
      ghostItem.parentNode.removeChild(ghostItem);
    }

    activeTouch = null;
    draggedItem = null;
    ghostItem = null;
  });

  // Empêcher le défilement pendant le drag
  list.addEventListener('touchmove', (e) => {
    if (activeTouch) {
      e.preventDefault();
    }
  }, { passive: false });
}

// --- EX1: Tri des étapes ---
(function() {
  const list = $('#orderList');
  if (!list) return;
  
  // Mélanger les éléments
  const items = Array.from(list.querySelectorAll('.chip'));
  const correctOrder = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
  
  function shuffleArray(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  
  let shuffled = shuffleArray(items);
  let attempt = 0;
  while (shuffled.map(li => li.dataset.key).join(',') === correctOrder.join(',') && attempt < 5) {
    shuffled = shuffleArray(items);
    attempt++;
  }
  
  // Vider et réinsérer les éléments mélangés
  list.innerHTML = '';
  shuffled.forEach(el => list.appendChild(el));
  
  // Drag and drop pour desktop
  let dragEl = null;
  
  list.addEventListener('dragstart', (e) => {
    const li = e.target.closest('.chip');
    if (!li) return;
    dragEl = li;
    li.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  });
  
  list.addEventListener('dragend', (e) => {
    const li = e.target.closest('.chip');
    if (li) li.classList.remove('dragging');
    dragEl = null;
  });
  
  list.addEventListener('dragover', (e) => {
    e.preventDefault();
    const afterEl = getDragAfterEl(list, e.clientY);
    if (!dragEl) return;
    if (afterEl) {
      list.insertBefore(dragEl, afterEl);
    } else {
      list.appendChild(dragEl);
    }
  });
  
  function getDragAfterEl(container, y) {
    const els = [...container.querySelectorAll('.chip:not(.dragging)')];
    return els.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
  
  // Vérification
  $('[data-check-order]').addEventListener('click', () => {
    const order = [...list.querySelectorAll('.chip')].map(li => li.dataset.key);
    const correct = order.join(',') === correctOrder.join(',');
    const ex = list.closest('.exercise');
    const id = ex.dataset.ex;
    const resKey = 'ex' + id;
    
    if (results[resKey] !== undefined) {
      const fb = $('#fb1');
      if (fb) {
        fb.textContent = 'Déjà validé.';
        fb.className = 'feedback good';
      }
      return;
    }
    
    const pts = correct ? Number(ex.dataset.points) : 0;
    results[resKey] = pts;
    save();
    updateScore();
    
    const fb = $('#fb1');
    if (fb) {
      fb.textContent = correct ? '✓ Bon ordre !' : '✗ Ordre incorrect. Réessaie.';
      fb.className = 'feedback ' + (correct ? 'good' : 'bad');
    }
    
    if (correct) unlockSolutions(ex);
  });
})();

// --- Drag & drop matching pour EX2, EX4, EX6, EX7, EX10 ---
(function() {
  const dragItems = $$('.label[draggable="true"]');
  let dragSrc = null;
  
  dragItems.forEach(el => {
    el.addEventListener('dragstart', (e) => {
      dragSrc = el;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', el.dataset.key);
    });
    
    el.addEventListener('dragend', () => {
      dragSrc = null;
    });
  });
  
  const zones = $$('.zone[data-accept]');
  
  zones.forEach(zone => {
    zone.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    
    zone.addEventListener('drop', e => {
      e.preventDefault();
      const key = e.dataTransfer.getData('text/plain');
      if (!key) return;
      
      const accepted = zone.dataset.accept;
      if (accepted !== key) return;
      
      const label = dragItems.find(el => el.dataset.key === key);
      if (!label) return;
      
      zone.innerHTML = '<span class="zone-chip" data-key="' + key + '">' + label.textContent + '</span>';
      zone.dataset.filled = key;
      zone.classList.add('filled');
      label.style.display = 'none';
    });
  });
  
  $$('[data-check-match]').forEach(btn => {
    btn.addEventListener('click', e => {
      const ex = e.target.closest('.exercise');
      if (!ex) return;
      
      const id = ex.dataset.ex;
      const resKey = 'ex' + id;
      
      if (results[resKey] !== undefined) {
        const fb = ex.querySelector('.feedback');
        if (fb) {
          fb.textContent = 'Déjà validé.';
          fb.className = 'feedback good';
        }
        return;
      }
      
      const zones = $$('.zone[data-accept]', ex);
      const correct = zones.every(zone => zone.dataset.filled === zone.dataset.accept);
      const pts = correct ? Number(ex.dataset.points) : 0;
      
      results[resKey] = pts;
      save();
      updateScore();
      
      const fb = ex.querySelector('.feedback');
      if (fb) {
        fb.textContent = correct ? '✓ Bon appariement !' : '✗ Appariement incorrect. Réessaie.';
        fb.className = 'feedback ' + (correct ? 'good' : 'bad');
      }
      
      if (correct) unlockSolutions(ex);
    });
  });
})();

// --- QCM pour EX3, EX4, EX5, EX6, EX8 ---
(function() {
  $$('[data-check-qcm]').forEach(btn => {
    btn.addEventListener('click', e => {
      const qcm = e.target.closest('.qcm');
      const ex = e.target.closest('.exercise');
      if (!qcm || !ex) return;
      
      const id = ex.dataset.ex;
      const correctValue = e.target.dataset.correct;
      const radios = qcm.querySelectorAll('input[type=radio]');
      const selected = Array.from(radios).find(r => r.checked);
      const isCorrect = !!selected && selected.value === correctValue;
      
      // Créer une clé unique pour chaque QCM
      const qcmIndex = Array.from($$('[data-check-qcm]', ex)).indexOf(btn);
      const resKey = 'ex' + id + '_qcm' + (qcmIndex > 0 ? qcmIndex : '');
      
      if (results[resKey] !== undefined) {
        const fb = qcm.querySelector('.feedback');
        if (fb) {
          fb.textContent = isCorrect ? 'Déjà validé.' : 'Déjà validé (score figé).';
          fb.className = 'feedback ' + (isCorrect ? 'good' : 'bad');
        }
        return;
      }
      
      const pts = isCorrect ? Number(ex.dataset.points) : 0;
      results[resKey] = pts;
      save();
      updateScore();
      
      const fb = qcm.querySelector('.feedback');
      if (fb) {
        fb.textContent = isCorrect ? '✓ Bonne réponse !' : '✗ Réponse incorrecte. Réessaie.';
        fb.className = 'feedback ' + (isCorrect ? 'good' : 'bad');
      }
      
      if (isCorrect) unlockSolutions(ex);
    });
  });
})();

// --- EX5: Détection d'erreurs ---
(function() {
  const btn = $('#checkErr');
  if (!btn) return;
  
  btn.addEventListener('click', () => {
    const ex = btn.closest('.exercise');
    const id = ex.dataset.ex;
    const resKey = 'ex' + id;
    
    if (results[resKey] !== undefined) {
      const fb = $('#fb5');
      if (fb) {
        fb.textContent = 'Déjà validé.';
        fb.className = 'feedback good';
      }
      return;
    }
    
    const checks = $$('.err:checked', ex);
    const correct = checks.length === 2 && 
                   checks.some(c => c.value === 'ko1') && 
                   checks.some(c => c.value === 'ko2');
    const pts = correct ? Number(ex.dataset.points) : 0;
    
    results[resKey] = pts;
    save();
    updateScore();
    
    const fb = $('#fb5');
    if (fb) {
      fb.textContent = correct ? '✓ Erreurs bien identifiées !' : '✗ Pas tout à fait. Réessaie.';
      fb.className = 'feedback ' + (correct ? 'good' : 'bad');
    }
    
    if (correct) unlockSolutions(ex);
  });
})();

// Initialisation
totalEl.textContent = totalPoints();
updateScore();
show(0);

// Configurer le tactile après le chargement
document.addEventListener('DOMContentLoaded', () => {
  setupTouchDragAndDrop();
  setupTouchSorting();
});
</script>
